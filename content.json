{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"Cochee","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Java动态代理","slug":"Java动态代理","date":"2016-04-11T15:36:46.000Z","updated":"2016-04-12T00:43:50.000Z","comments":true,"path":"2016/04/11/Java动态代理/","link":"","permalink":"http://yoursite.com/2016/04/11/Java动态代理/","excerpt":"","keywords":null,"text":"Java 动态代理代理类在程序运行前不存在、运行时由程序动态生成的代理方式称为动态代理。Java 提供了动态代理的实现方式，可以在运行时刻动态生成代理类。这种代理方式的一大好处是可以方便对代理类的函数做统一或特殊处理，如记录所有函数执行时间、所有函数执行前添加验证判断、对某个特殊函数进行特殊操作，而不用像静态代理方式那样需要修改每个函数。 动态代理实例实现动态代理包括三步：(1). 新建委托类；(2). 实现InvocationHandler接口，这是负责连接代理类和委托类的中间类必须实现的接口；(3). 通过Proxy类新建代理类对象。 下面通过实例具体介绍，假如现在我们想统计某个类所有函数的执行时间，传统的方式是在类的每个函数前打点统计，动态代理方式如下： 1 新建委托类12345678910111213141516171819202122232425262728293031323334353637public interface Operate &#123; public void operateMethod1(); public void operateMethod2(); public void operateMethod3();&#125;public class OperateImpl implements Operate &#123; @Override public void operateMethod1() &#123; System.out.println(\"Invoke operateMethod1\"); sleep(110); &#125; @Override public void operateMethod2() &#123; System.out.println(\"Invoke operateMethod2\"); sleep(120); &#125; @Override public void operateMethod3() &#123; System.out.println(\"Invoke operateMethod3\"); sleep(130); &#125; private static void sleep(long millSeconds) &#123; try &#123; Thread.sleep(millSeconds); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; Operate是一个接口，定了了一些函数，我们要统计这些函数的执行时间。OperateImpl是委托类，实现Operate接口。每个函数简单输出字符串，并等待一段时间。动态代理要求委托类必须实现了某个接口，比如这里委托类OperateImpl实现了Operate。 2 实现 InvocationHandler 接口123456789101112131415161718public class TimingInvocationHandler implements InvocationHandler &#123; private Object target; public TimingInvocationHandler() &#123;&#125; public TimingInvocationHandler(Object target) &#123; this.target = target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; long start = System.currentTimeMillis(); Object obj = method.invoke(target, args); System.out.println(method.getName() + \" cost time is:\" + (System.currentTimeMillis() - start)); return obj; &#125;&#125; target属性表示委托类对象。 InvocationHandler是负责连接代理类和委托类的中间类必须实现的接口。其中只有一个 1public Object invoke(Object proxy, Method method, Object[] args) 函数需要去实现，参数：proxy表示下面通过 Proxy.newProxyInstance() 生成的代理类对象。method表示代理对象被调用的函数。args表示代理对象被调用的函数的参数。 调用代理对象的每个函数实际最终都是调用了InvocationHandler的invoke函数。这里我们在invoke实现中添加了开始结束计时，其中还调用了委托类对象target的相应函数，这样便完成了统计执行时间的需求。invoke函数中我们也可以通过对method做一些判断，从而对某些函数特殊处理。 3 通过 Proxy 类静态函数生成代理对象123456789101112131415public class Main &#123; public static void main(String[] args) &#123; // create proxy instance TimingInvocationHandler timingInvocationHandler = new TimingInvocationHandler(new OperateImpl()); Operate operate = (Operate)(Proxy.newProxyInstance(Operate.class.getClassLoader(), new Class[] &#123;Operate.class&#125;, timingInvocationHandler)); // call method of proxy instance operate.operateMethod1(); System.out.println(); operate.operateMethod2(); System.out.println(); operate.operateMethod3(); &#125;&#125; 这里先将委托类对象new OperateImpl()作为TimingInvocationHandler构造函数入参创建timingInvocationHandler对象；然后通过Proxy.newProxyInstance(…)函数新建了一个代理对象，实际代理类就是在这时候动态生成的。我们调用该代理对象的函数就会调用到timingInvocationHandler的invoke函数(是不是有点类似静态代理)，而invoke函数实现中调用委托类对象new OperateImpl()相应的 method(是不是有点类似静态代理)。 1public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) loader表示类加载器interfaces表示委托类的接口，生成代理类时需要实现这些接口h是InvocationHandler实现类对象，负责连接代理类和委托类的中间类 可以这样理解，如上的动态代理实现实际是双层的静态代理，开发者提供了委托类 B，程序动态生成了代理类 A。开发者还需要提供一个实现了InvocationHandler的子类 C，子类 C 连接代理类 A 和委托类 B，它是代理类 A 的委托类，委托类 B 的代理类。用户直接调用代理类 A 的对象，A 将调用转发给委托类 C，委托类 C 再将调用转发给它的委托类 B。 动态代理原理1 生成的动态代理类代码下面是上面示例程序运行时自动生成的动态代理类代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149import com.vallny.java.test.dynamicproxy.Operate;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.lang.reflect.UndeclaredThrowableException;public final class $Proxy0 extends Proxy implements Operate&#123; private static Method m4; private static Method m1; private static Method m5; private static Method m0; private static Method m3; private static Method m2; public $Proxy0(InvocationHandler paramInvocationHandler) throws &#123; super(paramInvocationHandler); &#125; public final void operateMethod1() throws &#123; try &#123; h.invoke(this, m4, null); return; &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final boolean equals(Object paramObject) throws &#123; try &#123; return ((Boolean)h.invoke(this, m1, new Object[] &#123; paramObject &#125;)).booleanValue(); &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final void operateMethod2() throws &#123; try &#123; h.invoke(this, m5, null); return; &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final int hashCode() throws &#123; try &#123; return ((Integer)h.invoke(this, m0, null)).intValue(); &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final void operateMethod3() throws &#123; try &#123; h.invoke(this, m3, null); return; &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final String toString() throws &#123; try &#123; return (String)h.invoke(this, m2, null); &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; static &#123; try &#123; m4 = Class.forName(\"com.vallny.java.test.dynamicproxy.Operate\").getMethod(\"operateMethod1\", new Class[0]); m1 = Class.forName(\"java.lang.Object\").getMethod(\"equals\", new Class[] &#123; Class.forName(\"java.lang.Object\") &#125;); m5 = Class.forName(\"com.vallny.java.test.dynamicproxy.Operate\").getMethod(\"operateMethod2\", new Class[0]); m0 = Class.forName(\"java.lang.Object\").getMethod(\"hashCode\", new Class[0]); m3 = Class.forName(\"com.vallny.java.test.dynamicproxy.Operate\").getMethod(\"operateMethod3\", new Class[0]); m2 = Class.forName(\"java.lang.Object\").getMethod(\"toString\", new Class[0]); return; &#125; catch (NoSuchMethodException localNoSuchMethodException) &#123; throw new NoSuchMethodError(localNoSuchMethodException.getMessage()); &#125; catch (ClassNotFoundException localClassNotFoundException) &#123; throw new NoClassDefFoundError(localClassNotFoundException.getMessage()); &#125; &#125;&#125; 从中我们可以看出动态生成的代理类是以$Proxy为类名前缀，继承自Proxy，并且实现了Proxy.newProxyInstance(…)第二个参数传入的所有接口的类。如果代理类实现的接口中存在非 public 接口，则其包名为该接口的包名，否则为com.sun.proxy。其中的operateMethod1()、operateMethod2()、operateMethod3()函数都是直接交给h去处理，h在父类Proxy中定义为 1protected InvocationHandler h; 即为Proxy.newProxyInstance(…)第三个参数。所以InvocationHandler的子类 C 连接代理类 A 和委托类 B，它是代理类 A 的委托类，委托类 B 的代理类。 2 生成动态代理类原理以下针对 Java 1.6 源码进行分析，动态代理类是在调用Proxy.newProxyInstance(…)函数时生成的。 newProxyInstance(…)函数代码如下： 123456789101112131415161718192021222324252627282930public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException&#123; if (h == null) &#123; throw new NullPointerException(); &#125; /* * Look up or generate the designated proxy class. */ Class cl = getProxyClass(loader, interfaces); /* * Invoke its constructor with the designated invocation handler. */ try &#123; Constructor cons = cl.getConstructor(constructorParams); return (Object) cons.newInstance(new Object[] &#123; h &#125;); &#125; catch (NoSuchMethodException e) &#123; throw new InternalError(e.toString()); &#125; catch (IllegalAccessException e) &#123; throw new InternalError(e.toString()); &#125; catch (InstantiationException e) &#123; throw new InternalError(e.toString()); &#125; catch (InvocationTargetException e) &#123; throw new InternalError(e.toString()); &#125;&#125; 从中可以看出它先调用getProxyClass(loader, interfaces)得到动态代理类，然后将InvocationHandler作为代理类构造函数入参新建代理类对象。 getProxyClass(…)函数代码及解释如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159/** * 得到代理类，不存在则动态生成 * @param loader 代理类所属 ClassLoader * @param interfaces 代理类需要实现的接口 * @return */public static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces) throws IllegalArgumentException&#123; if (interfaces.length &gt; 65535) &#123; throw new IllegalArgumentException(\"interface limit exceeded\"); &#125; // 代理类类对象 Class proxyClass = null; /* collect interface names to use as key for proxy class cache */ String[] interfaceNames = new String[interfaces.length]; Set interfaceSet = new HashSet(); // for detecting duplicates /** * 入参 interfaces 检验，包含三部分 * （1）是否在入参指定的 ClassLoader 内 * （2）是否是 Interface * （3）interfaces 中是否有重复 */ for (int i = 0; i &lt; interfaces.length; i++) &#123; String interfaceName = interfaces[i].getName(); Class interfaceClass = null; try &#123; interfaceClass = Class.forName(interfaceName, false, loader); &#125; catch (ClassNotFoundException e) &#123; &#125; if (interfaceClass != interfaces[i]) &#123; throw new IllegalArgumentException( interfaces[i] + \" is not visible from class loader\"); &#125; if (!interfaceClass.isInterface()) &#123; throw new IllegalArgumentException( interfaceClass.getName() + \" is not an interface\"); &#125; if (interfaceSet.contains(interfaceClass)) &#123; throw new IllegalArgumentException( \"repeated interface: \" + interfaceClass.getName()); &#125; interfaceSet.add(interfaceClass); interfaceNames[i] = interfaceName; &#125; // 以接口名对应的 List 作为缓存的 key Object key = Arrays.asList(interfaceNames); /* * loaderToCache 是个双层的 Map * 第一层 key 为 ClassLoader，第二层 key 为 上面的 List，value 为代理类的弱引用 */ Map cache; synchronized (loaderToCache) &#123; cache = (Map) loaderToCache.get(loader); if (cache == null) &#123; cache = new HashMap(); loaderToCache.put(loader, cache); &#125; &#125; /* * 以上面的接口名对应的 List 为 key 查找代理类，如果结果为： * (1) 弱引用，表示代理类已经在缓存中 * (2) pendingGenerationMarker 对象，表示代理类正在生成中，等待生成完成通知。 * (3) null 表示不在缓存中且没有开始生成，添加标记到缓存中，继续生成代理类 */ synchronized (cache) &#123; do &#123; Object value = cache.get(key); if (value instanceof Reference) &#123; proxyClass = (Class) ((Reference) value).get(); &#125; if (proxyClass != null) &#123; // proxy class already generated: return it return proxyClass; &#125; else if (value == pendingGenerationMarker) &#123; // proxy class being generated: wait for it try &#123; cache.wait(); &#125; catch (InterruptedException e) &#123; &#125; continue; &#125; else &#123; cache.put(key, pendingGenerationMarker); break; &#125; &#125; while (true); &#125; try &#123; String proxyPkg = null; // package to define proxy class in /* * 如果 interfaces 中存在非 public 的接口，则所有非 public 接口必须在同一包下面，后续生成的代理类也会在该包下面 */ for (int i = 0; i &lt; interfaces.length; i++) &#123; int flags = interfaces[i].getModifiers(); if (!Modifier.isPublic(flags)) &#123; String name = interfaces[i].getName(); int n = name.lastIndexOf('.'); String pkg = ((n == -1) ? \"\" : name.substring(0, n + 1)); if (proxyPkg == null) &#123; proxyPkg = pkg; &#125; else if (!pkg.equals(proxyPkg)) &#123; throw new IllegalArgumentException( \"non-public interfaces from different packages\"); &#125; &#125; &#125; if (proxyPkg == null) &#123; // if no non-public proxy interfaces, proxyPkg = \"\"; // use the unnamed package &#125; &#123; // 得到代理类的类名，jdk 1.6 版本中缺少对这个生成类已经存在的处理。 long num; synchronized (nextUniqueNumberLock) &#123; num = nextUniqueNumber++; &#125; String proxyName = proxyPkg + proxyClassNamePrefix + num; // 动态生成代理类的字节码 // 最终调用 sun.misc.ProxyGenerator.generateClassFile() 得到代理类相关信息写入 DataOutputStream 实现 byte[] proxyClassFile = ProxyGenerator.generateProxyClass( proxyName, interfaces); try &#123; // native 层实现，虚拟机加载代理类并返回其类对象 proxyClass = defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length); &#125; catch (ClassFormatError e) &#123; throw new IllegalArgumentException(e.toString()); &#125; &#125; // add to set of all generated proxy classes, for isProxyClass proxyClasses.put(proxyClass, null); &#125; finally &#123; // 代理类生成成功则保存到缓存，否则从缓存中删除，然后通知等待的调用 synchronized (cache) &#123; if (proxyClass != null) &#123; cache.put(key, new WeakReference(proxyClass)); &#125; else &#123; cache.remove(key); &#125; cache.notifyAll(); &#125; &#125; return proxyClass;&#125; 函数主要包括三部分： 入参 interfaces 检验，包含是否在入参指定的 ClassLoader 内、是否是 Interface、interfaces 中是否有重复 以接口名对应的 List 为 key 查找代理类，如果结果为： 弱引用，表示代理类已经在缓存中； pendingGenerationMarker 对象，表示代理类正在生成中，等待生成完成返回； null 表示不在缓存中且没有开始生成，添加标记到缓存中，继续生成代理类。 如果代理类不存在调用ProxyGenerator.generateProxyClass(…)生成代理类并存入缓存，通知在等待的缓存。 函数中几个注意的地方： 代理类的缓存 key 为接口名对应的 List，接口顺序不同表示不同的 key 即不同的代理类。 如果 interfaces 中存在非 public 的接口，则所有非 public 接口必须在同一包下面，后续生成的代理类也会在该包下面。 代理类如果在 ClassLoader 中已经存在的情况没有做处理。 可以开启 System Properties 的sun.misc.ProxyGenerator.saveGeneratedFiles开关，保存动态类到目的地址。","raw":null,"content":null,"categories":[],"tags":[]},{"title":"c语言学习笔记","slug":"c语言学习笔记","date":"2016-04-11T04:18:17.000Z","updated":"2016-04-11T15:36:14.000Z","comments":true,"path":"2016/04/11/c语言学习笔记/","link":"","permalink":"http://yoursite.com/2016/04/11/c语言学习笔记/","excerpt":"","keywords":null,"text":"#memset memset() 函数用来将指定内存的前n个字节设置为特定的值，其原型为：void * memset( void * ptr, int value, size_t num ); 参数说明：ptr 为要操作的内存的指针。value 为要设置的值。你既可以向 value 传递 int 类型的值，也可以传递 char 类型的值，int 和 char 可以根据 ASCII 码相互转换。num 为 ptr 的前 num 个字节，size_t 就是unsigned int。 【函数说明】memset() 会将 ptr 所指的内存区域的前 num 个字节的值都设置为 value，然后返回指向 ptr 的指针。 memset() 可以将一段内存空间全部设置为特定的值，所以经常用来初始化字符数组。例如： char str[20]; memset(str, '\\0', sizeof(str)-1); 【返回值】返回指向 ptr 的指针。 注意：参数 value 虽声明为 int，但必须是 unsigned char，所以范围在0 到255 之间。","raw":null,"content":null,"categories":[],"tags":[]},{"title":"helloworld","slug":"helloworld","date":"2016-04-09T17:24:25.000Z","updated":"2016-04-10T08:45:24.000Z","comments":true,"path":"2016/04/10/helloworld/","link":"","permalink":"http://yoursite.com/2016/04/10/helloworld/","excerpt":"","keywords":null,"text":"Hello world","raw":null,"content":null,"categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2016-04-09T17:15:07.000Z","updated":"2016-04-09T17:15:07.000Z","comments":true,"path":"2016/04/10/hello-world/","link":"","permalink":"http://yoursite.com/2016/04/10/hello-world/","excerpt":"","keywords":null,"text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","raw":null,"content":null,"categories":[],"tags":[]}]}